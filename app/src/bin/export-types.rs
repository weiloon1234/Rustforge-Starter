//! Exports Rust contract types to TypeScript.
//!
//! Uses `ts-rs` to convert Rust types with `#[derive(TS)]` into TypeScript
//! definitions, then writes them to `frontend/src/` alongside static framework
//! types (ApiResponse, DataTable*, enums).
//!
//! Run: `cargo run -p app --bin export-types`
//! Or:  `make gen-types`

use std::fs;
use std::path::Path;
use ts_rs::TS;

// ── Generated types (ts-rs) ──────────────────────────────────

/// A generated TypeScript file: imports + ts-rs type definitions.
struct TsFile {
    /// Relative path from `frontend/src/`, e.g. `admin/types/admin.ts`
    rel_path: &'static str,
    /// Import lines prepended to the file.
    imports: &'static [&'static str],
    /// TypeScript definitions produced by ts-rs (collected at runtime).
    definitions: Vec<String>,
}

fn main() {
    let base = Path::new("frontend/src");

    // ── 1. Contract types via ts-rs ─────────────────────────
    let mut files: Vec<TsFile> = Vec::new();

    // admin/types/admin.ts
    {
        use app::contracts::api::v1::admin::*;
        files.push(TsFile {
            rel_path: "admin/types/admin.ts",
            imports: &[r#"import type { AdminType, Permission } from "./enums";"#],
            definitions: vec![
                CreateAdminInput::export_to_string().expect("CreateAdminInput"),
                UpdateAdminInput::export_to_string().expect("UpdateAdminInput"),
                AdminOutput::export_to_string().expect("AdminOutput"),
                AdminDeleteOutput::export_to_string().expect("AdminDeleteOutput"),
            ],
        });
    }

    // admin/types/admin-auth.ts
    {
        use app::contracts::api::v1::admin_auth::*;
        files.push(TsFile {
            rel_path: "admin/types/admin-auth.ts",
            imports: &[r#"import type { AdminType, AuthClientType } from "./enums";"#],
            definitions: vec![
                AdminLoginInput::export_to_string().expect("AdminLoginInput"),
                AdminRefreshInput::export_to_string().expect("AdminRefreshInput"),
                AdminLogoutInput::export_to_string().expect("AdminLogoutInput"),
                AdminProfileUpdateInput::export_to_string().expect("AdminProfileUpdateInput"),
                AdminPasswordUpdateInput::export_to_string().expect("AdminPasswordUpdateInput"),
                AdminAuthOutput::export_to_string().expect("AdminAuthOutput"),
                AdminMeOutput::export_to_string().expect("AdminMeOutput"),
                AdminProfileUpdateOutput::export_to_string().expect("AdminProfileUpdateOutput"),
                AdminPasswordUpdateOutput::export_to_string().expect("AdminPasswordUpdateOutput"),
                AdminLogoutOutput::export_to_string().expect("AdminLogoutOutput"),
            ],
        });
    }

    // admin/types/datatable-admin.ts
    {
        use app::contracts::datatable::admin::admin::*;
        files.push(TsFile {
            rel_path: "admin/types/datatable-admin.ts",
            imports: &[
                r#"import type { AdminType } from "./enums";"#,
                r#"import type { DataTableQueryRequestBase, DataTableEmailExportRequestBase } from "../../shared/types/datatable";"#,
            ],
            definitions: vec![
                AdminDatatableQueryInput::export_to_string().expect("AdminDatatableQueryInput"),
                AdminDatatableEmailExportInput::export_to_string().expect("AdminDatatableEmailExportInput"),
            ],
        });
    }

    // Write ts-rs generated files
    for ts_file in &files {
        let path = base.join(ts_file.rel_path);
        write_file(&path, &assemble(ts_file));
    }

    // ── 2. Static framework types (not derived from Rust structs) ──
    //
    // These mirror core-web types that don't live in the app crate.
    // The scaffold also writes identical initial copies; this binary
    // overwrites them to keep everything in sync after contract changes.
    let statics: &[(&str, &str)] = &[
        ("shared/types/api.ts", SHARED_API_TS),
        ("shared/types/datatable.ts", SHARED_DATATABLE_TS),
        ("shared/types/index.ts", SHARED_INDEX_TS),
        ("admin/types/enums.ts", ADMIN_ENUMS_TS),
        ("admin/types/index.ts", ADMIN_INDEX_TS),
        ("user/types/index.ts", USER_INDEX_TS),
    ];
    for (rel, content) in statics {
        write_file(&base.join(rel), content);
    }

    println!("\nTypeScript types regenerated in frontend/src/");
}

// ── Helpers ──────────────────────────────────────────────────

fn assemble(f: &TsFile) -> String {
    let header = "// Auto-generated by `cargo run -p app --bin export-types`.\n\
                  // Do not edit manually — run `make gen-types` to regenerate.\n";
    let mut out = String::from(header);
    for imp in f.imports {
        out.push_str(imp);
        out.push('\n');
    }
    out.push('\n');
    for (i, def) in f.definitions.iter().enumerate() {
        if i > 0 {
            out.push('\n');
        }
        out.push_str(def);
        out.push('\n');
    }
    out
}

fn write_file(path: &Path, content: &str) {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).expect("failed to create directory");
    }
    fs::write(path, content).unwrap_or_else(|e| {
        panic!("failed to write {}: {e}", path.display());
    });
    println!("  wrote {}", path.display());
}

// ── Static TypeScript content ────────────────────────────────
// Framework types from core-web that can't derive TS directly.

const SHARED_API_TS: &str = "\
export interface ApiResponse<T> {
  data: T;
  message?: string;
}

export interface ApiErrorResponse {
  message: string;
  errors?: Record<string, string[]>;
}
";

const SHARED_DATATABLE_TS: &str = "\
export type DataTablePaginationMode = \"offset\" | \"cursor\";

export type DataTableSortDirection = \"asc\" | \"desc\";

export interface DataTableQueryRequestBase {
  include_meta?: boolean;
  page?: number | null;
  per_page?: number | null;
  cursor?: string | null;
  pagination_mode?: DataTablePaginationMode | null;
  sorting_column?: string | null;
  sorting?: DataTableSortDirection | null;
  timezone?: string | null;
  created_at_from?: string | null;
  created_at_to?: string | null;
}

export interface DataTableEmailExportRequestBase {
  query: DataTableQueryRequestBase;
  recipients: string[];
  subject?: string | null;
  export_file_name?: string | null;
}

export type DataTableFilterFieldType =
  | \"text\"
  | \"select\"
  | \"number\"
  | \"date\"
  | \"datetime\"
  | \"boolean\";

export interface DataTableFilterOptionDto {
  label: string;
  value: string;
}

export interface DataTableFilterFieldDto {
  field: string;
  filter_key: string;
  type: DataTableFilterFieldType;
  label: string;
  placeholder?: string;
  description?: string;
  options?: DataTableFilterOptionDto[];
}

export interface DataTableColumnMetaDto {
  name: string;
  data_type: string;
  sortable: boolean;
  localized: boolean;
  filter_ops: string[];
}

export interface DataTableRelationColumnMetaDto {
  relation: string;
  column: string;
  data_type: string;
  filter_ops: string[];
}

export interface DataTableDefaultsDto {
  sorting_column: string;
  sorted: string;
  per_page: number;
  export_ignore_columns: string[];
  timestamp_columns: string[];
  unsortable: string[];
}

export interface DataTableDiagnosticsDto {
  duration_ms: number;
  auto_filters_applied: number;
  unknown_filters: string[];
  unknown_filter_mode: string;
}

export interface DataTableMetaDto {
  model_key: string;
  defaults: DataTableDefaultsDto;
  columns: DataTableColumnMetaDto[];
  relation_columns: DataTableRelationColumnMetaDto[];
  filter_rows: DataTableFilterFieldDto[][];
}

export interface DataTableQueryResponse<T> {
  records: T[];
  per_page: number;
  total_records: number;
  total_pages: number;
  page: number;
  pagination_mode: string;
  has_more?: boolean;
  next_cursor?: string;
  diagnostics: DataTableDiagnosticsDto;
  meta?: DataTableMetaDto;
}

export type DataTableEmailExportState =
  | \"waiting_csv\"
  | \"uploading\"
  | \"sending\"
  | \"completed\"
  | \"failed\";

export interface DataTableEmailExportStatusDto {
  state: DataTableEmailExportState;
  recipients: string[];
  subject?: string;
  link_url?: string;
  error?: string;
  updated_at_unix: number;
  sent_at_unix?: number;
}

export interface DataTableEmailExportQueuedDto {
  job_id: string;
  csv_state: string;
  email_state: DataTableEmailExportState;
}

export interface DataTableExportStatusResponseDto {
  job_id: string;
  model_key: string;
  csv_state: string;
  csv_error?: string;
  csv_file_name?: string;
  csv_content_type?: string;
  csv_total_records?: number;
  email?: DataTableEmailExportStatusDto;
}
";

const SHARED_INDEX_TS: &str = "\
export * from \"./api\";
export * from \"./datatable\";
";

const ADMIN_ENUMS_TS: &str = "\
export type AdminType = \"Developer\" | \"SuperAdmin\" | \"Admin\";

export type Permission = \"admin.read\" | \"admin.manage\";

export type AuthClientType = \"web\" | \"mobile\";
";

const ADMIN_INDEX_TS: &str = "\
export * from \"./enums\";
export * from \"./admin\";
export * from \"./admin-auth\";
export * from \"./datatable-admin\";
";

const USER_INDEX_TS: &str = "\
// Add user-specific types here as user contracts are created.
// Example:
//   export * from \"./user\";
//   export * from \"./user-auth\";
";
