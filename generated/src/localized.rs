#![allow(dead_code)]
// AUTO-GENERATED FILE â€” DO NOT EDIT
// Generated by build.rs from schema.toml + configs.toml

use core_db::platform::attachments::types::AttachmentRules;
pub const DEFAULT_LOCALE: &str = "en";

pub const DEFAULT_TIMEZONE: &str = "+08:00";

pub const SUPPORTED_LOCALES: &[&str] = &[
    "en",
    "zh",
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize, schemars::JsonSchema)]
pub enum Locale {
    #[serde(rename = "en")]
    En,
    #[serde(rename = "zh")]
    Zh,
}

impl Locale {
    pub fn as_str(&self) -> &'static str {
        match self {
            Locale::En => "en",
            Locale::Zh => "zh",
        }
    }
}

impl From<Locale> for String {
    fn from(l: Locale) -> Self {
        l.as_str().to_string()
    }
}

impl std::fmt::Display for Locale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, schemars::JsonSchema)]
pub struct MultiLang {
    pub en: String,
    pub zh: String,
}

impl MultiLang {
    pub fn get(&self, locale: &str) -> &str {
        match locale {
            "en" => &self.en,
            "zh" => &self.zh,
            _ => &self.en,
        }
    }
}

pub trait LocalizedMapHelper {
    fn get_multilang(&self, field: &str, owner_id: i64) -> Option<MultiLang>;
}

impl LocalizedMapHelper for core_db::platform::localized::types::LocalizedMap {
    fn get_multilang(&self, field: &str, owner_id: i64) -> Option<MultiLang> {
        let by_owner = self.inner.get(field)?;
        let by_locale = by_owner.get(&owner_id)?;
        if by_locale.is_empty() { return None; }
        let mut out = MultiLang {
            en: String::new(),
            zh: String::new(),
        };
        for &loc in SUPPORTED_LOCALES {
            if let Some(v) = by_locale.get(loc) {
                match loc {
                    "en" => out.en = v.clone(),
                    "zh" => out.zh = v.clone(),
                    _ => {}
                }
            }
        }
        if let Some(default_val) = by_locale.get(DEFAULT_LOCALE) {
            if out.en.is_empty() { out.en = default_val.clone(); }
            if out.zh.is_empty() { out.zh = default_val.clone(); }
        }
        Some(out)
    }
}

pub fn get_attachment_rules(name: &str) -> Option<AttachmentRules> {
    match name {
        _ => None,
    }
}

