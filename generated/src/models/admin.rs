// AUTO-GENERATED FILE â€” DO NOT EDIT
// Generated by build.rs from schema.toml + configs.toml
#![allow(unused)]
use anyhow::Result;
use serde::{Deserialize, Serialize};
use schemars::JsonSchema;
use sqlx::FromRow;
use core_db::common::sql::{BindValue, Op, OrderDir, RawClause, RawGroupExpr, RawJoinKind, RawJoinSpec, RawOrderExpr, RawSelectExpr, bind, bind_query, bind_scalar, generate_snowflake_i64, DbConn};
use core_db::common::pagination::resolve_per_page;
use core_datatable::{AutoDataTable, BoxFuture, DataTableColumnDescriptor, DataTableContext, DataTableInput, DataTableRelationColumnDescriptor, GeneratedTableAdapter, ParsedFilter, SortDirection};
use core_db::platform::localized::types::LocalizedMap;
use core_db::platform::localized::repo::LocalizedRepo;
use crate::generated::models::common::{Page, renumber_placeholders};
use core_db::common::collection::TypedCollectionExt;
use crate::extensions::admin::types::*;
use super::common::*;
use super::enums::*;

const HAS_CREATED_AT: bool = true;
const HAS_UPDATED_AT: bool = true;
const HAS_SOFT_DELETE: bool = true;

#[derive(Debug, Clone, FromRow, Serialize, Deserialize, JsonSchema)]
#[doc(hidden)]
pub struct AdminRow {
    pub id: uuid::Uuid,
    pub email: String,
    pub password: String,
    pub name: String,
    pub admin_type: AdminType,
    #[serde(with = "time::serde::rfc3339")]
    #[schemars(with = "String")]
    pub created_at: time::OffsetDateTime,
    #[serde(with = "time::serde::rfc3339")]
    #[schemars(with = "String")]
    pub updated_at: time::OffsetDateTime,
    #[serde(with = "time::serde::rfc3339::option")]
    #[schemars(with = "String")]
    pub deleted_at: Option<time::OffsetDateTime>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct AdminView {
    pub id: uuid::Uuid,
    pub email: String,
    pub password: String,
    pub name: String,
    pub admin_type: AdminType,
    #[schemars(with = "String")]
    pub created_at: time::OffsetDateTime,
    #[schemars(with = "String")]
    pub updated_at: time::OffsetDateTime,
    #[schemars(with = "String")]
    pub deleted_at: Option<time::OffsetDateTime>,
}

impl AdminView {
    pub fn update<'db>(&self, db: impl Into<DbConn<'db>>) -> AdminUpdate<'db> {
        Admin::new(db.into(), None).update().where_id(Op::Eq, self.id)
    }
    pub fn update_with<'db>(&self, model: &Admin<'db>) -> AdminUpdate<'db> {
        model.update().where_id(Op::Eq, self.id)
    }
    pub fn to_json(&self) -> AdminJson {
        AdminJson {
            id: self.id.clone(),
            email: self.email.clone(),
            password: self.password.clone(),
            name: self.name.clone(),
            admin_type: self.admin_type.clone(),
            created_at: self.created_at.clone(),
            updated_at: self.updated_at.clone(),
            deleted_at: self.deleted_at.clone(),
        }
    }
}

pub trait AdminViewsExt {
    fn ids(&self) -> Vec<uuid::Uuid>;
    fn pluck<R>(&self, f: impl Fn(&AdminView) -> R) -> Vec<R>;
    fn key_by<K>(&self, f: impl Fn(&AdminView) -> K) -> std::collections::HashMap<K, AdminView> where K: Eq + std::hash::Hash;
    fn group_by<K>(&self, f: impl Fn(&AdminView) -> K) -> std::collections::HashMap<K, Vec<AdminView>> where K: Eq + std::hash::Hash;
}

impl AdminViewsExt for Vec<AdminView> {
    fn ids(&self) -> Vec<uuid::Uuid> { self.as_slice().pluck_typed(|v| v.id.clone()) }
    fn pluck<R>(&self, f: impl Fn(&AdminView) -> R) -> Vec<R> { self.as_slice().pluck_typed(f) }
    fn key_by<K>(&self, f: impl Fn(&AdminView) -> K) -> std::collections::HashMap<K, AdminView> where K: Eq + std::hash::Hash { self.as_slice().key_by_typed(f) }
    fn group_by<K>(&self, f: impl Fn(&AdminView) -> K) -> std::collections::HashMap<K, Vec<AdminView>> where K: Eq + std::hash::Hash { self.as_slice().group_by_typed(f) }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[doc(hidden)]
pub struct AdminJson {
    pub id: uuid::Uuid,
    pub email: String,
    pub password: String,
    pub name: String,
    pub admin_type: AdminType,
    #[schemars(with = "String")]
    pub created_at: time::OffsetDateTime,
    #[schemars(with = "String")]
    pub updated_at: time::OffsetDateTime,
    #[schemars(with = "String")]
    pub deleted_at: Option<time::OffsetDateTime>,
}

fn hydrate_view(row: AdminRow, loc: &LocalizedMap, base_url: Option<&str>) -> AdminView {
    let mut view = AdminView {
        id: row.id,
        email: row.email,
        password: row.password,
        name: row.name,
        admin_type: row.admin_type,
        created_at: row.created_at,
        updated_at: row.updated_at,
        deleted_at: row.deleted_at,
    };
    view
}

#[derive(Debug, Clone, Copy, JsonSchema)]
pub enum AdminCol {
    Id,
    Email,
    Password,
    Name,
    AdminType,
    CreatedAt,
    UpdatedAt,
    DeletedAt,
}

impl AdminCol {
    pub const fn all() -> &'static [AdminCol] {
        &[AdminCol::Id, AdminCol::Email, AdminCol::Password, AdminCol::Name, AdminCol::AdminType, AdminCol::CreatedAt, AdminCol::UpdatedAt, AdminCol::DeletedAt]
    }
    pub const fn as_sql(self) -> &'static str {
        match self {
            AdminCol::Id => "id",
            AdminCol::Email => "email",
            AdminCol::Password => "password",
            AdminCol::Name => "name",
            AdminCol::AdminType => "admin_type",
            AdminCol::CreatedAt => "created_at",
            AdminCol::UpdatedAt => "updated_at",
            AdminCol::DeletedAt => "deleted_at",
        }
    }
}

pub struct Admin<'db> {
    db: DbConn<'db>,
    base_url: Option<String>,
}

impl<'db> Admin<'db> {
    pub const TABLE: &'static str = "admin";
    pub const PK: &'static str = "id";
    pub fn new(db: impl Into<DbConn<'db>>, base_url: Option<String>) -> Self { Self { db: db.into(), base_url } }
    pub fn query(&self) -> AdminQuery<'db> { AdminQuery::new(self.db.clone(), self.base_url.clone()) }
    pub fn insert(&self) -> AdminInsert<'db> { AdminInsert::new(self.db.clone(), self.base_url.clone()) }
    pub fn update(&self) -> AdminUpdate<'db> { AdminUpdate::new(self.db.clone(), self.base_url.clone()) }
    pub async fn find(&self, id: uuid::Uuid) -> Result<Option<AdminView>> {
        self.query().find(id).await
    }
    pub async fn delete(&self, id: uuid::Uuid) -> Result<u64> {
        self.query().where_id(Op::Eq, id).delete().await
    }
    pub async fn restore(&self, id: uuid::Uuid) -> Result<u64> {
        self.query().where_id(Op::Eq, id).restore().await
    }
}

#[derive(Clone)]
pub struct AdminQuery<'db> {
    db: DbConn<'db>,
    base_url: Option<String>,
    select_sql: Option<String>,
    from_sql: Option<String>,
    count_sql: Option<String>,
    distinct: bool,
    distinct_on: Option<String>,
    lock_sql: Option<&'static str>,
    join_sql: Vec<String>,
    join_binds: Vec<BindValue>,
    where_sql: Vec<String>,
    order_sql: Vec<String>,
    group_by_sql: Vec<String>,
    having_sql: Vec<String>,
    having_binds: Vec<BindValue>,
    offset: Option<i64>,
    limit: Option<i64>,
    binds: Vec<BindValue>,
    with_deleted: bool,
    only_deleted: bool,
}

impl<'db> AdminQuery<'db> {
    pub fn new(db: DbConn<'db>, base_url: Option<String>) -> Self {
        Self { db, base_url, select_sql: Some("id, email, password, name, admin_type, created_at, updated_at, deleted_at".to_string()), from_sql: None, count_sql: None, distinct: false, distinct_on: None, lock_sql: None, join_sql: vec![], join_binds: vec![], where_sql: vec![], order_sql: vec![], group_by_sql: vec![], having_sql: vec![], having_binds: vec![], offset: None, limit: None, binds: vec![], with_deleted: false, only_deleted: false }
    }
    pub fn unsafe_sql(self) -> AdminUnsafeQuery<'db> { AdminUnsafeQuery::new(self) }
    pub fn where_id(mut self, op: Op, val: uuid::Uuid) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Id.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_id_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Id.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_email(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Email.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_email_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Email.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_password(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Password.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_password_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Password.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_name(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Name.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_name_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Name.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_admin_type(mut self, op: Op, val: AdminType) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::AdminType.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_admin_type_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::AdminType.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_created_at(mut self, op: Op, val: time::OffsetDateTime) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::CreatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_created_at_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::CreatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_updated_at(mut self, op: Op, val: time::OffsetDateTime) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::UpdatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_updated_at_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::UpdatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_deleted_at(mut self, op: Op, val: Option<time::OffsetDateTime>) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::DeletedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_deleted_at_raw<T: Into<BindValue>>(mut self, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::DeletedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_key(self, id: uuid::Uuid) -> Self { self.where_id(Op::Eq, id) }
    pub fn where_key_in<T: Clone + Into<BindValue>>(self, vals: &[T]) -> Self { self.where_in(AdminCol::Id, vals) }
    pub fn where_col<T: Into<BindValue>>(mut self, col: AdminCol, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", col.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    fn where_raw<T: Into<BindValue>>(mut self, clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = clause.into();
        let incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos + 1, &ph);
            idx += 1;
        }
        self.where_sql.push(clause);
        self.binds.extend(incoming);
        self
    }
    pub fn where_in<T: Clone + Into<BindValue>>(mut self, col: AdminCol, vals: &[T]) -> Self {
        if vals.is_empty() {
            self.where_sql.push("1=0".to_string());
            return self;
        }
        let start = self.binds.len() + 1;
        let mut placeholders = Vec::with_capacity(vals.len());
        for (i, v) in vals.iter().enumerate() {
            placeholders.push(format!("${}", start + i));
            self.binds.push(v.clone().into());
        }
        let clause = format!("{} IN ({})", col.as_sql(), placeholders.join(", "));
        self.where_sql.push(clause);
        self
    }
    pub fn where_not_in<T: Clone + Into<BindValue>>(mut self, col: AdminCol, vals: &[T]) -> Self {
        if vals.is_empty() { return self; }
        let start = self.binds.len() + 1;
        let mut placeholders = Vec::with_capacity(vals.len());
        for (i, v) in vals.iter().enumerate() {
            placeholders.push(format!("${}", start + i));
            self.binds.push(v.clone().into());
        }
        let clause = format!("{} NOT IN ({})", col.as_sql(), placeholders.join(", "));
        self.where_sql.push(clause);
        self
    }
    pub fn where_between<T: Into<BindValue>>(mut self, col: AdminCol, low: T, high: T) -> Self {
        let idx1 = self.binds.len() + 1;
        let idx2 = idx1 + 1;
        self.where_sql.push(format!("{} BETWEEN ${} AND ${}", col.as_sql(), idx1, idx2));
        self.binds.push(low.into());
        self.binds.push(high.into());
        self
    }
    pub fn where_null(mut self, col: AdminCol) -> Self {
        self.where_sql.push(format!("{} IS NULL", col.as_sql()));
        self
    }
    pub fn where_not_null(mut self, col: AdminCol) -> Self {
        self.where_sql.push(format!("{} IS NOT NULL", col.as_sql()));
        self
    }
    pub fn or_where_col<T: Into<BindValue>>(mut self, col: AdminCol, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        let clause = format!("{} {} ${}", col.as_sql(), op.as_sql(), idx);
        if let Some(last) = self.where_sql.pop() {
            self.where_sql.push(format!("({} OR {})", last, clause));
        } else {
            self.where_sql.push(clause);
        }
        self.binds.push(val.into());
        self
    }
    fn or_where_raw<T: Into<BindValue>>(mut self, clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = clause.into();
        let incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos + 1, &ph);
            idx += 1;
        }
        if let Some(last) = self.where_sql.pop() {
            self.where_sql.push(format!("({} OR {})", last, clause));
        } else {
            self.where_sql.push(clause);
        }
        self.binds.extend(incoming);
        self
    }
    pub fn where_group(self, f: impl FnOnce(Self) -> Self) -> Self {
        let start_where = self.where_sql.len();
        let grouped = f(self);
        let mut result = grouped;
        if result.where_sql.len() > start_where {
            let group_clauses: Vec<String> = result.where_sql.drain(start_where..).collect();
            let grouped_sql = format!("({})", group_clauses.join(" AND "));
            result.where_sql.push(grouped_sql);
        }
        result
    }
    pub fn or_where_group(self, f: impl FnOnce(Self) -> Self) -> Self {
        let start_where = self.where_sql.len();
        let grouped = f(self);
        let mut result = grouped;
        if result.where_sql.len() > start_where {
            let group_clauses: Vec<String> = result.where_sql.drain(start_where..).collect();
            let grouped_sql = format!("({})", group_clauses.join(" AND "));
            if let Some(last) = result.where_sql.pop() {
                result.where_sql.push(format!("({} OR {})", last, grouped_sql));
            } else {
                result.where_sql.push(grouped_sql);
            }
        }
        result
    }
    pub fn select_cols(mut self, cols: &[AdminCol]) -> Self {
        if cols.is_empty() {
            self.select_sql = Some("id, email, password, name, admin_type, created_at, updated_at, deleted_at".to_string());
        } else {
            let mut seen = std::collections::BTreeSet::new();
            let mut list: Vec<String> = "id, email, password, name, admin_type, created_at, updated_at, deleted_at".split(',').map(|s| s.trim().to_string()).collect();
            for s in &list { seen.insert(s.clone()); }
            for c in cols { let s = c.as_sql().to_string(); if seen.insert(s.clone()) { list.push(s); } }
            self.select_sql = Some(list.join(", "));
        }
        self
    }
    pub fn add_select_cols(mut self, cols: &[AdminCol]) -> Self {
        let mut seen = std::collections::BTreeSet::new();
        let mut list: Vec<String> = match self.select_sql.take() {
            Some(s) if !s.is_empty() => s.split(',').map(|s| s.trim().to_string()).collect(),
            _ => "id, email, password, name, admin_type, created_at, updated_at, deleted_at".split(',').map(|s| s.trim().to_string()).collect(),
        };
        for s in &list { seen.insert(s.clone()); }
        for c in cols { let s = c.as_sql().to_string(); if seen.insert(s.clone()) { list.push(s); } }
        self.select_sql = Some(list.join(", "));
        self
    }
    fn select_raw(mut self, sql: impl Into<String>) -> Self {
        let s = sql.into();
        if s.is_empty() {
            self.select_sql = Some("id, email, password, name, admin_type, created_at, updated_at, deleted_at".to_string());
        } else {
            self.select_sql = Some(format!("id, email, password, name, admin_type, created_at, updated_at, deleted_at, {}", s));
        }
        self
    }
    fn add_select_raw(mut self, sql: impl Into<String>) -> Self {
        let s = sql.into();
        if s.is_empty() { return self; }
        let mut base = self.select_sql.take().unwrap_or_else(|| "id, email, password, name, admin_type, created_at, updated_at, deleted_at".to_string());
        if !base.is_empty() { base.push_str(", "); }
        base.push_str(&s);
        self.select_sql = Some(base);
        self
    }
    fn inner_join_raw<T: Into<BindValue>>(mut self, table: impl Into<String>, on_clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = format!("INNER JOIN {} ON {}", table.into(), on_clause.into());
        let mut incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.join_binds.len() + self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos+1, &ph);
            idx += 1;
        }
        self.join_sql.push(clause);
        self.join_binds.append(&mut incoming);
        self
    }
    fn left_join_raw<T: Into<BindValue>>(mut self, table: impl Into<String>, on_clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = format!("LEFT JOIN {} ON {}", table.into(), on_clause.into());
        let mut incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.join_binds.len() + self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos+1, &ph);
            idx += 1;
        }
        self.join_sql.push(clause);
        self.join_binds.append(&mut incoming);
        self
    }
    fn right_join_raw<T: Into<BindValue>>(mut self, table: impl Into<String>, on_clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = format!("RIGHT JOIN {} ON {}", table.into(), on_clause.into());
        let mut incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.join_binds.len() + self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos+1, &ph);
            idx += 1;
        }
        self.join_sql.push(clause);
        self.join_binds.append(&mut incoming);
        self
    }
    fn full_join_raw<T: Into<BindValue>>(mut self, table: impl Into<String>, on_clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = format!("FULL OUTER JOIN {} ON {}", table.into(), on_clause.into());
        let mut incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.join_binds.len() + self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos+1, &ph);
            idx += 1;
        }
        self.join_sql.push(clause);
        self.join_binds.append(&mut incoming);
        self
    }
    pub fn order_by(mut self, col: AdminCol, dir: OrderDir) -> Self {
        self.order_sql.push(format!("{} {}", col.as_sql(), dir.as_sql()));
        self
    }
    pub fn order_by_nulls_first(mut self, col: AdminCol, dir: OrderDir) -> Self {
        self.order_sql.push(format!("{} {} NULLS FIRST", col.as_sql(), dir.as_sql()));
        self
    }
    pub fn order_by_nulls_last(mut self, col: AdminCol, dir: OrderDir) -> Self {
        self.order_sql.push(format!("{} {} NULLS LAST", col.as_sql(), dir.as_sql()));
        self
    }
    pub fn distinct(mut self) -> Self { self.distinct = true; self }
    pub fn distinct_on(mut self, cols: &[AdminCol]) -> Self {
        if cols.is_empty() { return self; }
        let list: Vec<&'static str> = cols.iter().map(|c| c.as_sql()).collect();
        self.distinct_on = Some(list.join(", "));
        self
    }
    pub fn select(mut self, cols: &[AdminCol]) -> Self {
        let names: Vec<&str> = cols.iter().map(|c| c.as_sql()).collect();
        self.select_sql = Some(names.join(", "));
        self
    }
    fn join(mut self, table: &str, first: &str, op: &str, second: &str) -> Self {
        self.join_sql.push(format!("JOIN {} ON {} {} {}", table, first, op, second));
        self
    }
    fn left_join(mut self, table: &str, first: &str, op: &str, second: &str) -> Self {
        self.join_sql.push(format!("LEFT JOIN {} ON {} {} {}", table, first, op, second));
        self
    }
    fn right_join(mut self, table: &str, first: &str, op: &str, second: &str) -> Self {
        self.join_sql.push(format!("RIGHT JOIN {} ON {} {} {}", table, first, op, second));
        self
    }
    fn from_raw(mut self, sql: &str) -> Self {
        self.from_sql = Some(sql.to_string());
        self
    }
    fn count_sql(mut self, sql: &str) -> Self {
        self.count_sql = Some(sql.to_string());
        self
    }
    fn where_exists<T: Into<BindValue>>(mut self, clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = clause.into();
        let incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos + 1, &ph);
            idx += 1;
        }
        self.where_sql.push(format!("EXISTS ({})", clause));
        self.binds.extend(incoming);
        self
    }
    fn select_subquery(mut self, alias: &str, sql: &str) -> Self {
        let current = self.select_sql.get_or_insert_with(|| "*".to_string());
        current.push_str(&format!(", ({}) AS {}", sql, alias));
        self
    }

    pub fn for_update(mut self) -> Self { self.lock_sql = Some("FOR UPDATE"); self }
    pub fn for_no_key_update(mut self) -> Self { self.lock_sql = Some("FOR NO KEY UPDATE"); self }
    pub fn for_share(mut self) -> Self { self.lock_sql = Some("FOR SHARE"); self }
    pub fn for_key_share(mut self) -> Self { self.lock_sql = Some("FOR KEY SHARE"); self }
    pub fn group_by(mut self, cols: &[AdminCol]) -> Self {
        for c in cols {
            self.group_by_sql.push(c.as_sql().to_string());
        }
        self
    }
    pub fn having_raw<T: Into<BindValue>>(mut self, clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = clause.into();
        let incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.having_binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos + 1, &ph);
            idx += 1;
        }
        self.having_sql.push(clause);
        self.having_binds.extend(incoming);
        self
    }
    pub fn limit(mut self, n: i64) -> Self {
        self.limit = Some(n);
        self
    }
    pub fn offset(mut self, n: i64) -> Self {
        self.offset = Some(n);
        self
    }
    pub fn with_deleted(mut self) -> Self { self.with_deleted = true; self }
    pub fn only_deleted(mut self) -> Self { self.only_deleted = true; self }
    pub async fn get_as<T>(self) -> Result<Vec<T>>
    where
        T: for<'r> sqlx::FromRow<'r, sqlx::postgres::PgRow> + Send + Unpin + 'static,
    {
        let Self { db, select_sql, from_sql, distinct, distinct_on, lock_sql, join_sql, join_binds, where_sql, order_sql, group_by_sql, having_sql, having_binds, offset, limit, binds, .. } = self;
        let mut where_sql = where_sql;
        let select_clause = match (distinct, distinct_on.as_ref()) {
            (false, None) => select_sql.unwrap_or_else(|| "*".to_string()),
            (true, None) => format!("DISTINCT {}", select_sql.unwrap_or_else(|| "*".to_string())),
            (_, Some(on)) => format!("DISTINCT ON ({}) {}", on, select_sql.unwrap_or_else(|| "*".to_string())),
        };
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let mut sql = format!("SELECT {} FROM {}", select_clause, table_name);
        if !join_sql.is_empty() { sql.push(' '); sql.push_str(&join_sql.join(" ")); }
        if !where_sql.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&where_sql.join(" AND "));
        }
        if !group_by_sql.is_empty() {
             sql.push_str(" GROUP BY ");
             sql.push_str(&group_by_sql.join(", "));
        }
        if !having_sql.is_empty() {
             sql.push_str(" HAVING ");
             sql.push_str(&having_sql.join(" AND "));
        }
        if !order_sql.is_empty() {
            sql.push_str(" ORDER BY ");
            sql.push_str(&order_sql.join(", "));
        }
        if let Some(off) = offset {
            sql.push_str(" OFFSET ");
            sql.push_str(&off.to_string());
        }
        if let Some(l) = limit {
            sql.push_str(" LIMIT ");
            sql.push_str(&l.to_string());
        }
        if let Some(lock) = lock_sql { sql.push(' '); sql.push_str(lock); }
        let mut q = sqlx::query_as::<_, T>(&sql);
        for b in binds { q = bind(q, b); }
        for b in join_binds { q = bind(q, b); }
        for b in having_binds { q = bind(q, b); }
        Ok(db.fetch_all(q).await?)
    }

    pub async fn get(self) -> Result<Vec<AdminView>> {
        let Self { db, base_url, select_sql, from_sql, distinct, distinct_on, lock_sql, join_sql, join_binds, where_sql, order_sql, group_by_sql, having_sql, having_binds, offset, limit, binds , with_deleted, only_deleted, .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let select_clause = match (distinct, distinct_on.as_ref()) {
            (false, None) => select_sql.unwrap_or_else(|| "*".to_string()),
            (true, None) => format!("DISTINCT {}", select_sql.unwrap_or_else(|| "*".to_string())),
            (_, Some(on)) => format!("DISTINCT ON ({}) {}", on, select_sql.unwrap_or_else(|| "*".to_string())),
        };
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let mut sql = format!("SELECT {} FROM {}", select_clause, table_name);
        if !join_sql.is_empty() { sql.push(' '); sql.push_str(&join_sql.join(" ")); }
        if !where_sql.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&where_sql.join(" AND "));
        }
        if !group_by_sql.is_empty() {
            sql.push_str(" GROUP BY ");
            sql.push_str(&group_by_sql.join(", "));
        }
        if !having_sql.is_empty() {
            sql.push_str(" HAVING ");
            sql.push_str(&having_sql.join(" AND "));
        }
        if !order_sql.is_empty() {
            sql.push_str(" ORDER BY ");
            sql.push_str(&order_sql.join(", "));
        }
        if let Some(off) = offset {
            sql.push_str(" OFFSET ");
            sql.push_str(&off.to_string());
        }
        if let Some(l) = limit {
            sql.push_str(" LIMIT ");
            sql.push_str(&l.to_string());
        }
        if let Some(lock) = lock_sql { sql.push(' '); sql.push_str(lock); }
        let mut q = sqlx::query_as::<_, AdminRow>(&sql);
        for b in binds {
            q = bind(q, b);
        }
        for b in join_binds { q = bind(q, b); }
        for b in having_binds { q = bind(q, b); }
        let rows = db.fetch_all(q).await?;
        let ids: Vec<uuid::Uuid> = rows.iter().map(|r| r.id.clone()).collect();
        let localized = LocalizedMap::default();
        let mut out_vec = Vec::with_capacity(rows.len());
        for r in rows {
            out_vec.push(hydrate_view(r, &LocalizedMap::default(), base_url.as_deref()));
        }
        Ok(out_vec)
    }

    pub async fn first(self) -> Result<Option<AdminView>> {
        let mut v = self.limit(1).get().await?;
        Ok(v.pop())
    }

    pub async fn first_or_fail(self) -> Result<AdminView> {
        self.first().await?.ok_or_else(|| anyhow::anyhow!("admin: record not found"))
    }

    pub async fn find(self, id: uuid::Uuid) -> Result<Option<AdminView>> {
        self.where_id(Op::Eq, id).first().await
    }
    pub async fn find_or_fail(self, id: uuid::Uuid) -> Result<AdminView> {
        self.find(id).await?.ok_or_else(|| anyhow::anyhow!("admin: record not found"))
    }
    pub async fn first_or_create(self, create: impl FnOnce(AdminInsert<'db>) -> AdminInsert<'db>) -> Result<AdminView> {
        let db = self.db.clone();
        let base_url = self.base_url.clone();
        if let Some(existing) = self.first().await? {
            return Ok(existing);
        }
        let insert_builder = create(AdminInsert::new(db, base_url));
        insert_builder.save().await
    }

    pub async fn update_or_create(
        self,
        on_update: impl FnOnce(AdminUpdate<'db>) -> AdminUpdate<'db>,
        on_create: impl FnOnce(AdminInsert<'db>) -> AdminInsert<'db>,
    ) -> Result<AdminView> {
        let db = self.db.clone();
        let base_url = self.base_url.clone();
        let where_sql = self.where_sql.clone();
        let binds = self.binds.clone();
        if let Some(existing) = self.first().await? {
            let mut update_builder = AdminUpdate::new(db.clone(), base_url.clone());
            update_builder.where_sql = where_sql;
            update_builder.binds = binds;
            let update_builder = on_update(update_builder);
            update_builder.save().await?;
            return Admin::new(db, base_url.clone()).query().find(existing.id).await.map(|r| r.unwrap());
        }
        let insert_builder = on_create(AdminInsert::new(db, base_url));
        insert_builder.save().await
    }

    pub async fn increment(self, col: AdminCol, amount: i64) -> Result<u64> {
        let db = self.db.clone();
        let mut where_sql = self.where_sql;
        let binds = self.binds;
        if HAS_SOFT_DELETE && !self.with_deleted {
            where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
        }
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let sql = format!("UPDATE admin SET {} = {} + {} {}", col.as_sql(), col.as_sql(), amount, where_clause);
        let mut q = sqlx::query(&sql);
        for b in binds { q = bind_query(q, b); }
        let res = db.execute(q).await?;
        Ok(res.rows_affected())
    }

    pub async fn decrement(self, col: AdminCol, amount: i64) -> Result<u64> {
        self.increment(col, -amount).await
    }

    pub async fn count(self) -> Result<i64> {
        let Self { db, from_sql, count_sql, join_sql, join_binds, where_sql, binds , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let count_expr = count_sql.unwrap_or_else(|| "COUNT(*)".to_string());
        let sql = format!("SELECT {} {}{}", count_expr, from_clause, where_clause);
        let mut q = sqlx::query_scalar::<_, i64>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let count = db.fetch_scalar(q).await?;
        Ok(count)
    }

    pub async fn exists(self) -> Result<bool> {
        Ok(self.count().await? > 0)
    }

    pub async fn pluck_ids(self) -> Result<Vec<uuid::Uuid>> {
        let Self { db, from_sql, join_sql, join_binds, where_sql, binds, order_sql, limit, offset , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() { format!("FROM {}", table_name) } else { format!("FROM {} {}", table_name, join_sql.join(" ")) };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let order_clause = if order_sql.is_empty() { String::new() } else { format!(" ORDER BY {}", order_sql.join(", ")) };
        let limit_clause = limit.map(|n| format!(" LIMIT {}", n)).unwrap_or_default();
        let offset_clause = offset.map(|n| format!(" OFFSET {}", n)).unwrap_or_default();
        let sql = format!("SELECT id {}{}{}{}{}", from_clause, where_clause, order_clause, limit_clause, offset_clause);
        let mut q = sqlx::query_scalar::<_, uuid::Uuid>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let ids = db.fetch_all_scalar(q).await?;
        Ok(ids)
    }

    pub async fn chunk<F, Fut>(mut self, size: i64, mut callback: F) -> Result<()>
    where
        F: FnMut(Vec<AdminView>) -> Fut,
        Fut: std::future::Future<Output = Result<bool>>,
    {
        let mut page = 0i64;
        let db = self.db.clone();
        loop {
            let mut query = AdminQuery::new(db.clone(), self.base_url.clone());
            query.where_sql = self.where_sql.clone();
            query.binds = self.binds.clone();
            query.order_sql = self.order_sql.clone();
            let rows = query.limit(size).offset(page * size).get().await?;
            if rows.is_empty() { break; }
            let should_continue = callback(rows).await?;
            if !should_continue { break; }
            page += 1;
        }
        Ok(())
    }

    pub fn latest(self) -> Self {
        self.order_by(AdminCol::CreatedAt, OrderDir::Desc)
    }

    pub fn oldest(self) -> Self {
        self.order_by(AdminCol::CreatedAt, OrderDir::Asc)
    }

    pub fn take(self, n: i64) -> Self {
        self.limit(n)
    }

    pub fn skip(self, n: i64) -> Self {
        self.offset(n)
    }

    pub async fn sole(self) -> Result<AdminView> {
        let mut rows = self.limit(2).get().await?;
        match rows.len() {
            0 => anyhow::bail!("sole: no record found"),
            1 => Ok(rows.remove(0)),
            _ => anyhow::bail!("sole: multiple records found"),
        }
    }

    fn order_by_raw(mut self, sql: impl Into<String>) -> Self {
        self.order_sql.push(sql.into());
        self
    }

    fn group_by_raw(mut self, sql: impl Into<String>) -> Self {
        self.group_by_sql.push(sql.into());
        self
    }

    pub async fn pluck_pair<K, V>(self, extract: impl Fn(&AdminView) -> (K, V)) -> Result<std::collections::HashMap<K, V>>
    where
        K: Eq + std::hash::Hash,
    {
        let rows = self.get().await?;
        Ok(rows.into_iter().map(|r| extract(&r)).collect())
    }

    pub async fn sum(self, col: AdminCol) -> Result<Option<f64>> {
        let Self { db, from_sql, join_sql, join_binds, where_sql, binds , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let sql = format!("SELECT SUM({}::DOUBLE PRECISION) {}{}", col.as_sql(), from_clause, where_clause);
        let mut q = sqlx::query_scalar::<_, Option<f64>>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let result = db.fetch_scalar(q).await?;
        Ok(result)
    }

    pub async fn avg(self, col: AdminCol) -> Result<Option<f64>> {
        let Self { db, from_sql, join_sql, join_binds, where_sql, binds , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let sql = format!("SELECT AVG({}::DOUBLE PRECISION) {}{}", col.as_sql(), from_clause, where_clause);
        let mut q = sqlx::query_scalar::<_, Option<f64>>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let result = db.fetch_scalar(q).await?;
        Ok(result)
    }

    pub async fn min_val(self, col: AdminCol) -> Result<Option<i64>> {
        let Self { db, from_sql, join_sql, join_binds, where_sql, binds , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let sql = format!("SELECT MIN({}) {}{}", col.as_sql(), from_clause, where_clause);
        let mut q = sqlx::query_scalar::<_, Option<i64>>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let result = db.fetch_scalar(q).await?;
        Ok(result)
    }

    pub async fn max_val(self, col: AdminCol) -> Result<Option<i64>> {
        let Self { db, from_sql, join_sql, join_binds, where_sql, binds , with_deleted, only_deleted , .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let sql = format!("SELECT MAX({}) {}{}", col.as_sql(), from_clause, where_clause);
        let mut q = sqlx::query_scalar::<_, Option<i64>>(&sql);
        for b in binds { q = bind_scalar(q, b); }
        for b in join_binds { q = bind_scalar(q, b); }
        let result = db.fetch_scalar(q).await?;
        Ok(result)
    }

    pub async fn paginate(self, page: i64, per_page: i64) -> Result<Page<AdminView>> {
        let page = if page < 1 { 1 } else { page };
        let per_page = resolve_per_page(per_page);
        let Self { db, base_url, select_sql, from_sql, count_sql, distinct, distinct_on, lock_sql, join_sql, join_binds, where_sql, order_sql, group_by_sql, having_sql, having_binds, offset: _, limit: _, binds , with_deleted, only_deleted, .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        let select_clause = match (distinct, distinct_on.as_ref()) {
            (false, None) => select_sql.unwrap_or_else(|| "*".to_string()),
            (true, None) => format!("DISTINCT {}", select_sql.unwrap_or_else(|| "*".to_string())),
            (_, Some(on)) => format!("DISTINCT ON ({}) {}", on, select_sql.unwrap_or_else(|| "*".to_string())),
        };
        let table_name = from_sql.unwrap_or_else(|| "admin".to_string());
        let from_clause = if join_sql.is_empty() {
            format!("FROM {}", table_name)
        } else {
            format!("FROM {} {}", table_name, join_sql.join(" "))
        };
        let where_clause = if where_sql.is_empty() { String::new() } else { format!(" WHERE {}", where_sql.join(" AND ")) };
        let count_expr = count_sql.unwrap_or_else(|| "COUNT(*)".to_string());
        let count_sql = if distinct || distinct_on.is_some() {
            format!("SELECT COUNT(*) FROM (SELECT {} {}{}) AS sub", select_clause, from_clause, where_clause)
        } else {
            format!("SELECT {} {}{}", count_expr, from_clause, where_clause)
        };
        let mut count_q = sqlx::query_scalar::<_, i64>(&count_sql);
        for b in binds.iter().cloned() { count_q = bind_scalar(count_q, b); }
        for b in join_binds.iter().cloned() { count_q = bind_scalar(count_q, b); }
        let total: i64 = db.fetch_scalar(count_q).await?;
        let last_page = ((total + per_page - 1) / per_page).max(1);
        let current_page = page.min(last_page);
        let offset_val = (current_page - 1) * per_page;
        let mut sql = format!("SELECT {} {}{}", select_clause, from_clause, where_clause);
        if !order_sql.is_empty() {
            sql.push_str(" ORDER BY ");
            sql.push_str(&order_sql.join(", "));
        }
        sql.push_str(&format!(" OFFSET {}", offset_val));
        sql.push_str(&format!(" LIMIT {}", per_page));
        if let Some(lock) = lock_sql { sql.push(' '); sql.push_str(lock); }
        let mut q = sqlx::query_as::<_, AdminRow>(&sql);
        for b in binds.iter().cloned() { q = bind(q, b); }
        for b in join_binds { q = bind(q, b); }
        let rows = db.fetch_all(q).await?;
        let ids: Vec<uuid::Uuid> = rows.iter().map(|r| r.id.clone()).collect();
        let localized = LocalizedMap::default();
        let mut data = Vec::with_capacity(rows.len());
        for r in rows {
            data.push(hydrate_view(r, &LocalizedMap::default(), base_url.as_deref()));
        }
        Ok(Page { data, total, per_page, current_page, last_page })
    }
    pub fn into_where_parts(self) -> (Vec<String>, Vec<BindValue>) {
        let Self { where_sql, binds, with_deleted, only_deleted, .. } = self;
        let mut where_sql = where_sql;
        if HAS_SOFT_DELETE {
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
        }
        (where_sql, binds)
    }
    pub async fn delete(self) -> Result<u64> {
        if self.limit.is_some() {
            anyhow::bail!("delete() does not support limit; add where clauses");
        }
        let Self { db, where_sql, binds, with_deleted, only_deleted, .. } = self;
        if where_sql.is_empty() { anyhow::bail!("delete(): no conditions set"); }
        if HAS_SOFT_DELETE {
            let mut where_sql = where_sql;
            if only_deleted {
                where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
            } else if !with_deleted {
                where_sql.push(format!("{} IS NULL", AdminCol::DeletedAt.as_sql()));
            }
            let idx = binds.len() + 1;
            let mut sql = format!("UPDATE admin SET {} = ${}", AdminCol::DeletedAt.as_sql(), idx);
            if !where_sql.is_empty() {
                sql.push_str(" WHERE ");
                sql.push_str(&where_sql.join(" AND "));
            }
            let mut q = sqlx::query(&sql);
            for b in binds { q = bind_query(q, b); }
            q = bind_query(q, time::OffsetDateTime::now_utc().into());
            let res = db.execute(q).await?;
            return Ok(res.rows_affected());
        }
        let mut sql = String::from("DELETE FROM admin");
        if !where_sql.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&where_sql.join(" AND "));
        }
        let mut q = sqlx::query(&sql);
        for b in binds { q = bind_query(q, b); }
        let res = db.execute(q).await?;
        Ok(res.rows_affected())
    }
    pub async fn restore(self) -> Result<u64> {
        if !HAS_SOFT_DELETE { anyhow::bail!("restore() not supported"); }
        if self.limit.is_some() {
            anyhow::bail!("restore() does not support limit; add where clauses");
        }
        let Self { db, where_sql, binds, with_deleted, only_deleted, .. } = self;
        if where_sql.is_empty() { anyhow::bail!("restore(): no conditions set"); }
        let mut where_sql = where_sql;
        if !with_deleted && !only_deleted {
            where_sql.push(format!("{} IS NOT NULL", AdminCol::DeletedAt.as_sql()));
        }
        let mut sql = format!("UPDATE admin SET {} = NULL", AdminCol::DeletedAt.as_sql());
        if !where_sql.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&where_sql.join(" AND "));
        }
        let mut q = sqlx::query(&sql);
        for b in binds { q = bind_query(q, b); }
        let res = db.execute(q).await?;
        Ok(res.rows_affected())
    }
}

#[doc(hidden)]
pub struct AdminUnsafeQuery<'db> {
    inner: AdminQuery<'db>,
}

impl<'db> AdminUnsafeQuery<'db> {
    fn new(inner: AdminQuery<'db>) -> Self { Self { inner } }
    pub fn where_raw(mut self, clause: RawClause) -> Self { let (sql, binds) = clause.into_parts(); self.inner = self.inner.where_raw(sql, binds); self }
    pub fn or_where_raw(mut self, clause: RawClause) -> Self { let (sql, binds) = clause.into_parts(); self.inner = self.inner.or_where_raw(sql, binds); self }
    pub fn join_raw(mut self, spec: RawJoinSpec) -> Self { let (kind, table, on, binds) = spec.into_parts(); self.inner = match kind { RawJoinKind::Inner => self.inner.inner_join_raw(table, on, binds), RawJoinKind::Left => self.inner.left_join_raw(table, on, binds), RawJoinKind::Right => self.inner.right_join_raw(table, on, binds), RawJoinKind::Full => self.inner.full_join_raw(table, on, binds), }; self }
    pub fn select_raw(mut self, expr: RawSelectExpr) -> Self { self.inner = self.inner.select_raw(expr.into_inner()); self }
    pub fn add_select_raw(mut self, expr: RawSelectExpr) -> Self { self.inner = self.inner.add_select_raw(expr.into_inner()); self }
    pub fn select_subquery(mut self, alias: impl Into<String>, sql: RawSelectExpr) -> Self { let alias = alias.into(); let raw = sql.into_inner(); self.inner = self.inner.select_subquery(&alias, &raw); self }
    pub fn from_raw(mut self, expr: RawSelectExpr) -> Self { let raw = expr.into_inner(); self.inner = self.inner.from_raw(&raw); self }
    pub fn count_sql(mut self, expr: RawSelectExpr) -> Self { let raw = expr.into_inner(); self.inner = self.inner.count_sql(&raw); self }
    pub fn where_exists(mut self, clause: RawClause) -> Self { let (sql, binds) = clause.into_parts(); self.inner = self.inner.where_exists(sql, binds); self }
    pub fn order_by_raw(mut self, expr: RawOrderExpr) -> Self { self.inner = self.inner.order_by_raw(expr.into_inner()); self }
    pub fn group_by_raw(mut self, expr: RawGroupExpr) -> Self { self.inner = self.inner.group_by_raw(expr.into_inner()); self }
    pub fn done(self) -> AdminQuery<'db> { self.inner }
}

pub struct AdminInsert<'db> {
    db: DbConn<'db>,
    base_url: Option<String>,
    cols: Vec<AdminCol>,
    binds: Vec<BindValue>,
    conflict_action: Option<&'static str>,
    conflict_cols: Vec<AdminCol>,
}

impl<'db> AdminInsert<'db> {
    pub fn new(db: DbConn<'db>, base_url: Option<String>) -> Self {
        Self {
            db,
            base_url,
            cols: vec![],
            binds: vec![],
            conflict_action: None,
            conflict_cols: vec![],
        }
    }
    pub fn set_id(mut self, val: uuid::Uuid) -> Self {
        self.cols.push(AdminCol::Id);
        self.binds.push(val.into());
        self
    }
    pub fn set_email(mut self, val: String) -> Self {
        self.cols.push(AdminCol::Email);
        self.binds.push(val.into());
        self
    }
    pub fn set_password(mut self, val: &str) -> anyhow::Result<Self> {
        let hashed = core_db::common::auth::hash::hash_password(val)?;
        self.cols.push(AdminCol::Password);
        self.binds.push(hashed.into());
        Ok(self)
    }
    pub fn set_password_raw(mut self, val: String) -> Self {
        self.cols.push(AdminCol::Password);
        self.binds.push(val.into());
        self
    }
    pub fn set_name(mut self, val: String) -> Self {
        self.cols.push(AdminCol::Name);
        self.binds.push(val.into());
        self
    }
    pub fn set_admin_type(mut self, val: AdminType) -> Self {
        self.cols.push(AdminCol::AdminType);
        self.binds.push(val.into());
        self
    }
    pub fn set_created_at(mut self, val: time::OffsetDateTime) -> Self {
        self.cols.push(AdminCol::CreatedAt);
        self.binds.push(val.into());
        self
    }
    pub fn set_updated_at(mut self, val: time::OffsetDateTime) -> Self {
        self.cols.push(AdminCol::UpdatedAt);
        self.binds.push(val.into());
        self
    }
    pub fn set_deleted_at(mut self, val: Option<time::OffsetDateTime>) -> Self {
        self.cols.push(AdminCol::DeletedAt);
        self.binds.push(val.into());
        self
    }
    pub fn on_conflict_do_nothing(mut self, conflict_cols: &[AdminCol]) -> Self {
        self.conflict_action = Some("DO NOTHING");
        self.conflict_cols = conflict_cols.to_vec();
        self
    }
    pub fn on_conflict_update(mut self, conflict_cols: &[AdminCol]) -> Self {
        self.conflict_action = Some("DO UPDATE");
        self.conflict_cols = conflict_cols.to_vec();
        self
    }
    pub async fn save(self) -> Result<AdminView> {
        let db_conn = self.db.clone();
        match db_conn {
            DbConn::Pool(pool) => {
                let tx = pool.begin().await?;
                let tx_lock = std::sync::Arc::new(tokio::sync::Mutex::new(tx));
                let view = {
                    let db = DbConn::tx(tx_lock.clone());
                    self.save_with_db(db).await?
                };
                let tx = std::sync::Arc::try_unwrap(tx_lock)
                    .map_err(|_| anyhow::anyhow!("transaction scope still has active handles"))?
                    .into_inner();
                tx.commit().await?;
                Ok(view)
            }
            DbConn::Tx(_) => self.save_with_db(db_conn).await,
        }
    }

    async fn save_with_db<'tx>(self, db: DbConn<'tx>) -> Result<AdminView> {
        let mut cols = self.cols;
        let mut binds = self.binds;
        if HAS_CREATED_AT && !cols.iter().any(|c| matches!(c, AdminCol::CreatedAt)) {
            let now = time::OffsetDateTime::now_utc();
            cols.push(AdminCol::CreatedAt);
            binds.push(now.into());
        }
        if HAS_UPDATED_AT && !cols.iter().any(|c| matches!(c, AdminCol::UpdatedAt)) {
            let now = time::OffsetDateTime::now_utc();
            cols.push(AdminCol::UpdatedAt);
            binds.push(now.into());
        }
        if cols.is_empty() {
            anyhow::bail!("insert: no columns set");
        }
        let col_sql: Vec<&'static str> = cols.iter().map(|c| c.as_sql()).collect();
        let placeholders: Vec<String> = (1..=binds.len()).map(|i| format!("${}", i)).collect();
        let mut sql = format!("INSERT INTO {} ({}) VALUES ({})", "admin", col_sql.join(", "), placeholders.join(", "));
        if let Some(action) = self.conflict_action {
            if !self.conflict_cols.is_empty() {
                let conflict_col_sql: Vec<&'static str> = self.conflict_cols.iter().map(|c| c.as_sql()).collect();
                sql.push_str(&format!(" ON CONFLICT ({}) {}", conflict_col_sql.join(", "), action));
                if action == "DO UPDATE" {
                    let set_clauses: Vec<String> = col_sql.iter().zip(placeholders.iter())
                        .filter(|(col, _)| !conflict_col_sql.contains(col))
                        .map(|(col, ph)| format!("{} = {}", col, ph))
                        .collect();
                    if !set_clauses.is_empty() {
                        sql.push_str(&format!(" SET {}", set_clauses.join(", ")));
                    }
                }
            }
        }
        sql.push_str(" RETURNING *");
        let mut q = sqlx::query_as::<_, AdminRow>(&sql);
        for b in binds {
            q = bind(q, b);
        }
        let row = db.fetch_one(q).await?;
        let localized = LocalizedMap::default();
        Ok(hydrate_view(row, &LocalizedMap::default(), self.base_url.as_deref()))
    }
}
pub struct AdminUpdate<'db> {
    db: DbConn<'db>,
    base_url: Option<String>,
    sets: Vec<(AdminCol, BindValue)>,
    where_sql: Vec<String>,
    binds: Vec<BindValue>,
}

impl<'db> AdminUpdate<'db> {
    pub fn new(db: DbConn<'db>, base_url: Option<String>) -> Self {
        Self {
            db,
            base_url,
            sets: vec![],
            where_sql: vec![],
            binds: vec![],
        }
    }
    pub fn unsafe_sql(self) -> AdminUnsafeUpdate<'db> { AdminUnsafeUpdate::new(self) }
    pub fn set_id(mut self, val: uuid::Uuid) -> Self {
        self.sets.push((AdminCol::Id , val.into()));
        self
    }
    pub fn set_email(mut self, val: String) -> Self {
        self.sets.push((AdminCol::Email , val.into()));
        self
    }
    pub fn set_password(mut self, val: &str) -> anyhow::Result<Self> {
        let hashed = core_db::common::auth::hash::hash_password(val)?;
        self.sets.push((AdminCol::Password , hashed.into()));
        Ok(self)
    }
    pub fn set_password_raw(mut self, val: String) -> Self {
        self.sets.push((AdminCol::Password , val.into()));
        self
    }
    pub fn set_name(mut self, val: String) -> Self {
        self.sets.push((AdminCol::Name , val.into()));
        self
    }
    pub fn set_admin_type(mut self, val: AdminType) -> Self {
        self.sets.push((AdminCol::AdminType , val.into()));
        self
    }
    pub fn set_created_at(mut self, val: time::OffsetDateTime) -> Self {
        self.sets.push((AdminCol::CreatedAt , val.into()));
        self
    }
    pub fn set_updated_at(mut self, val: time::OffsetDateTime) -> Self {
        self.sets.push((AdminCol::UpdatedAt , val.into()));
        self
    }
    pub fn set_deleted_at(mut self, val: Option<time::OffsetDateTime>) -> Self {
        self.sets.push((AdminCol::DeletedAt , val.into()));
        self
    }
    pub fn where_id(mut self, op: Op, val: uuid::Uuid) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Id.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_email(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Email.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_password(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Password.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_name(mut self, op: Op, val: String) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::Name.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_admin_type(mut self, op: Op, val: AdminType) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::AdminType.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_created_at(mut self, op: Op, val: time::OffsetDateTime) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::CreatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_updated_at(mut self, op: Op, val: time::OffsetDateTime) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::UpdatedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_deleted_at(mut self, op: Op, val: Option<time::OffsetDateTime>) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", AdminCol::DeletedAt.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    pub fn where_col<T: Into<BindValue>>(mut self, col: AdminCol, op: Op, val: T) -> Self {
        let idx = self.binds.len() + 1;
        self.where_sql.push(format!("{} {} ${}", col.as_sql(), op.as_sql(), idx));
        self.binds.push(val.into());
        self
    }
    fn where_raw<T: Into<BindValue>>(mut self, clause: impl Into<String>, binds: impl IntoIterator<Item = T>) -> Self {
        let mut clause = clause.into();
        let incoming: Vec<BindValue> = binds.into_iter().map(Into::into).collect();
        let mut idx = self.binds.len() + 1;
        while let Some(pos) = clause.find('?') {
            let ph = format!("${}", idx);
            clause.replace_range(pos..pos + 1, &ph);
            idx += 1;
        }
        self.where_sql.push(clause);
        self.binds.extend(incoming);
        self
    }
    pub async fn save(self) -> Result<u64> {
        if self.sets.is_empty() { anyhow::bail!("update: no columns set"); }
        if self.where_sql.is_empty() { anyhow::bail!("update: no conditions set"); }
        let db_conn = self.db.clone();
        match db_conn {
            DbConn::Pool(pool) => {
                let tx = pool.begin().await?;
                let tx_lock = std::sync::Arc::new(tokio::sync::Mutex::new(tx));
                let affected = {
                    let db = DbConn::tx(tx_lock.clone());
                    self.save_with_db(db).await?
                };
                let tx = std::sync::Arc::try_unwrap(tx_lock)
                    .map_err(|_| anyhow::anyhow!("transaction scope still has active handles"))?
                    .into_inner();
                tx.commit().await?;
                Ok(affected)
            }
            DbConn::Tx(_) => self.save_with_db(db_conn).await,
        }
    }

    async fn save_with_db<'tx>(self, db: DbConn<'tx>) -> Result<u64> {
        let (cols, set_binds): (Vec<_>, Vec<_>) = self.sets.into_iter().unzip();
        // find target ids for localized updates
        let select_sql = format!("SELECT id FROM admin WHERE {}", self.where_sql.join(" AND "));
        let mut select_q = sqlx::query_scalar::<_, i64>(&select_sql);
        for b in &self.binds { select_q = bind_scalar(select_q, b.clone()); }
        let target_ids = db.fetch_all_scalar(select_q).await?;
        let mut parts: Vec<String> = Vec::new();
        for (i, c) in cols.iter().enumerate() {
            parts.push(format!("{} = ${}", c.as_sql(), i + 1));
        }
        let offset = parts.len();
        let mut where_sql = self.where_sql;
        let binds = self.binds;
        let mut renumbered = Vec::with_capacity(where_sql.len());
        for clause in where_sql.drain(..) {
            renumbered.push(renumber_placeholders(&clause, offset + 1));
        }
        where_sql = renumbered;
        let mut sql = String::from("UPDATE admin SET ");
        sql.push_str(&parts.join(", "));
        if !where_sql.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&where_sql.join(" AND "));
        }
        let mut q = sqlx::query(&sql);
        for b in &set_binds { q = bind_query(q, b.clone()); }
        for b in &binds { q = bind_query(q, b.clone()); }
        let res = db.execute(q).await?;
        let mut target_ids = target_ids;
        if HAS_UPDATED_AT {
            let now = time::OffsetDateTime::now_utc();
            let idx = 1;
            let mut sql = format!("UPDATE admin SET {} = ${}", AdminCol::UpdatedAt.as_sql(), idx);
            if !where_sql.is_empty() {
                sql.push_str(" WHERE ");
                sql.push_str(&where_sql.join(" AND "));
            }
            let mut q = sqlx::query(&sql);
            for b in &set_binds { q = bind_query(q, b.clone()); }
            for b in &binds { q = bind_query(q, b.clone()); }
            q = bind_query(q, now.into());
            db.execute(q).await?;
            if target_ids.is_empty() {
                let select_sql = format!("SELECT id FROM admin WHERE {}", where_sql.join(" AND "));
                let mut select_q = sqlx::query_scalar::<_, i64>(&select_sql);
                for b in &binds { select_q = bind_scalar(select_q, b.clone()); }
                target_ids = db.fetch_all_scalar(select_q).await?;
            }
        }
        Ok(res.rows_affected())
    }
}
#[doc(hidden)]
pub struct AdminUnsafeUpdate<'db> {
    inner: AdminUpdate<'db>,
}

impl<'db> AdminUnsafeUpdate<'db> {
    fn new(inner: AdminUpdate<'db>) -> Self { Self { inner } }
    pub fn where_raw(mut self, clause: RawClause) -> Self { let (sql, binds) = clause.into_parts(); self.inner = self.inner.where_raw(sql, binds); self }
    pub fn done(self) -> AdminUpdate<'db> { self.inner }
}
pub struct AdminTableAdapter;
impl AdminTableAdapter {
    fn parse_col(name: &str) -> Option<AdminCol> {
        match name {
            "id" => Some(AdminCol::Id),
            "email" => Some(AdminCol::Email),
            "password" => Some(AdminCol::Password),
            "name" => Some(AdminCol::Name),
            "admin_type" => Some(AdminCol::AdminType),
            "created_at" => Some(AdminCol::CreatedAt),
            "updated_at" => Some(AdminCol::UpdatedAt),
            "deleted_at" => Some(AdminCol::DeletedAt),
            _ => None,
        }
    }
    fn parse_locale_field_for_relation(relation: &str, column: &str) -> Option<&'static str> {
        match (relation, column) {
            _ => None,
        }
    }
    fn parse_locale_field(name: &str) -> Option<&'static str> {
        match name {
            _ => None,
        }
    }
    fn parse_like_col(name: &str) -> Option<AdminCol> {
        match name {
            "email" => Some(AdminCol::Email),
            "password" => Some(AdminCol::Password),
            "name" => Some(AdminCol::Name),
            _ => None,
        }
    }
    fn parse_bind_for_col(name: &str, raw: &str) -> Option<BindValue> {
        match name {
            "id" => uuid::Uuid::parse_str(raw.trim()).ok().map(Into::into),
            "email" => Some(raw.trim().to_string().into()),
            "password" => Some(raw.trim().to_string().into()),
            "name" => Some(raw.trim().to_string().into()),
            "admin_type" => Some(Self::parse_bind(raw.trim())),
            "created_at" => Self::parse_datetime(raw.trim(), false).map(Into::into),
            "updated_at" => Self::parse_datetime(raw.trim(), false).map(Into::into),
            "deleted_at" => Self::parse_datetime(raw.trim(), false).map(Into::into),
            _ => None,
        }
    }
    fn parse_bind_for_relation(relation: &str, column: &str, raw: &str) -> Option<BindValue> {
        match (relation, column) {
            _ => None,
        }
    }
    fn parse_bind(raw: &str) -> BindValue {
        let trimmed = raw.trim();
        let lower = trimmed.to_ascii_lowercase(); if lower == "true" { return true.into(); } if lower == "false" { return false.into(); }
        if let Ok(v) = trimmed.parse::<i64>() { return v.into(); }
        if let Ok(v) = trimmed.parse::<f64>() { return v.into(); }
        if let Ok(v) = uuid::Uuid::parse_str(trimmed) { return v.into(); }
        if let Some(v) = Self::parse_datetime(trimmed, false) { return v.into(); }
        trimmed.to_string().into()
    }
    fn parse_datetime(raw: &str, end_of_day: bool) -> Option<time::OffsetDateTime> {
        let trimmed = raw.trim();
        if let Ok(dt) = time::OffsetDateTime::parse(trimmed, &time::format_description::well_known::Rfc3339) { return Some(dt); }
        if trimmed.len() == 10 {
            let date = time::Date::parse(trimmed, &time::macros::format_description!("[year]-[month]-[day]")).ok()?;
            let t = if end_of_day { time::Time::from_hms(23, 59, 59).ok()? } else { time::Time::MIDNIGHT };
            return Some(date.with_time(t).assume_offset(time::UtcOffset::UTC));
        }
        None
    }
}
impl GeneratedTableAdapter for AdminTableAdapter {
    type Query<'db> = AdminQuery<'db>;
    type Row = AdminView;
    fn model_key(&self) -> &'static str { "Admin" }
    fn sortable_columns(&self) -> &'static [&'static str] { &["id", "email", "password", "name", "admin_type", "created_at", "updated_at", "deleted_at"] }
    fn timestamp_columns(&self) -> &'static [&'static str] { &["created_at", "updated_at", "deleted_at"] }
    fn column_descriptors(&self) -> &'static [DataTableColumnDescriptor] {
        &[
            DataTableColumnDescriptor { name: "id", data_type: "uuid::Uuid", sortable: true, localized: false, filter_ops: &["eq", "gte", "lte"] },
            DataTableColumnDescriptor { name: "email", data_type: "String", sortable: true, localized: false, filter_ops: &["eq", "like", "gte", "lte"] },
            DataTableColumnDescriptor { name: "password", data_type: "String", sortable: true, localized: false, filter_ops: &["eq", "like", "gte", "lte"] },
            DataTableColumnDescriptor { name: "name", data_type: "String", sortable: true, localized: false, filter_ops: &["eq", "like", "gte", "lte"] },
            DataTableColumnDescriptor { name: "admin_type", data_type: "AdminType", sortable: true, localized: false, filter_ops: &["eq", "gte", "lte"] },
            DataTableColumnDescriptor { name: "created_at", data_type: "time::OffsetDateTime", sortable: true, localized: false, filter_ops: &["eq", "gte", "lte", "date_from", "date_to"] },
            DataTableColumnDescriptor { name: "updated_at", data_type: "time::OffsetDateTime", sortable: true, localized: false, filter_ops: &["eq", "gte", "lte", "date_from", "date_to"] },
            DataTableColumnDescriptor { name: "deleted_at", data_type: "Option<time::OffsetDateTime>", sortable: true, localized: false, filter_ops: &["eq", "gte", "lte", "date_from", "date_to"] },
        ]
    }
    fn relation_column_descriptors(&self) -> &'static [DataTableRelationColumnDescriptor] {
        &[
        ]
    }
    fn filter_patterns(&self) -> &'static [&'static str] {
        &[
            "f-<col>",
            "f-like-<col>",
            "f-gte-<col>",
            "f-lte-<col>",
            "f-date-from-<col>",
            "f-date-to-<col>",
            "f-like-any-<col1|col2|...>",
            "f-any-<col1|col2|...>",
            "f-has-<relation>-<col>",
            "f-has-like-<relation>-<col>",
        ]
    }
    fn apply_auto_filter<'db>(&self, query: AdminQuery<'db>, filter: &ParsedFilter, value: &str) -> anyhow::Result<Option<AdminQuery<'db>>> where Self: 'db {
        let trimmed = value.trim();
        if trimmed.is_empty() { return Ok(Some(query)); }
        match filter {
            ParsedFilter::Eq { column } => {
                let Some(col) = Self::parse_col(column.as_str()) else { return Ok(None); };
                let Some(bind) = Self::parse_bind_for_col(column.as_str(), trimmed) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Eq, bind)))
            }
            ParsedFilter::Like { column } => {
                let Some(col) = Self::parse_like_col(column.as_str()) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Like, format!("%{}%", trimmed))))
            }
            ParsedFilter::Gte { column } => {
                let Some(col) = Self::parse_col(column.as_str()) else { return Ok(None); };
                let Some(bind) = Self::parse_bind_for_col(column.as_str(), trimmed) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Ge, bind)))
            }
            ParsedFilter::Lte { column } => {
                let Some(col) = Self::parse_col(column.as_str()) else { return Ok(None); };
                let Some(bind) = Self::parse_bind_for_col(column.as_str(), trimmed) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Le, bind)))
            }
            ParsedFilter::DateFrom { column } => {
                let Some(col) = Self::parse_col(column.as_str()) else { return Ok(None); };
                let Some(ts) = Self::parse_datetime(trimmed, false) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Ge, ts)))
            }
            ParsedFilter::DateTo { column } => {
                let Some(col) = Self::parse_col(column.as_str()) else { return Ok(None); };
                let Some(ts) = Self::parse_datetime(trimmed, true) else { return Ok(None); };
                Ok(Some(query.where_col(col, Op::Le, ts)))
            }
            ParsedFilter::LocaleEq { column } => {
                Ok(None)
            }
            ParsedFilter::LocaleLike { column } => {
                Ok(None)
            }
            ParsedFilter::LikeAny { columns } => {
                let mut applied = false;
                let pattern = format!("%{}%", trimmed);
                let next = query.where_group(|group| {
                    let mut q = group;
                    for column in columns {
                        if let Some(col) = Self::parse_like_col(column.as_str()) {
                            if applied { q = q.or_where_col(col, Op::Like, pattern.clone()); } else { q = q.where_col(col, Op::Like, pattern.clone()); applied = true; }
                        }
                    }
                    q
                });
                if applied { Ok(Some(next)) } else { Ok(None) }
            }
            ParsedFilter::Any { columns } => {
                let mut applied = false;
                let next = query.where_group(|group| {
                    let mut q = group;
                    for column in columns {
                        if let Some(col) = Self::parse_col(column.as_str()) {
                            if let Some(bind) = Self::parse_bind_for_col(column.as_str(), trimmed) { if applied { q = q.or_where_col(col, Op::Eq, bind.clone()); } else { q = q.where_col(col, Op::Eq, bind.clone()); applied = true; } }
                        }
                    }
                    q
                });
                if applied { Ok(Some(next)) } else { Ok(None) }
            }
            ParsedFilter::Has { relation, column } => {
                match (relation.as_str(), column.as_str()) {
                    _ => Ok(None),
                }
            }
            ParsedFilter::HasLike { relation, column } => {
                let pattern = format!("%{}%", trimmed);
                match (relation.as_str(), column.as_str()) {
                    _ => Ok(None),
                }
            }
            ParsedFilter::LocaleHas { relation, column } => {
                let Some(field) = Self::parse_locale_field_for_relation(relation.as_str(), column.as_str()) else { return Ok(None); };
                let locale = core_i18n::current_locale().to_string();
                match (relation.as_str(), column.as_str()) {
                    _ => Ok(None),
                }
            }
            ParsedFilter::LocaleHasLike { relation, column } => {
                let Some(field) = Self::parse_locale_field_for_relation(relation.as_str(), column.as_str()) else { return Ok(None); };
                let locale = core_i18n::current_locale().to_string();
                let pattern = format!("%{}%", trimmed);
                match (relation.as_str(), column.as_str()) {
                    _ => Ok(None),
                }
            }
        }
    }
    fn apply_sort<'db>(&self, query: AdminQuery<'db>, column: &str, dir: SortDirection) -> anyhow::Result<AdminQuery<'db>> where Self: 'db {
        let dir = match dir { SortDirection::Asc => OrderDir::Asc, SortDirection::Desc => OrderDir::Desc };
        let next = match column {
            "id" => query.order_by(AdminCol::Id, dir),
            "email" => query.order_by(AdminCol::Email, dir),
            "password" => query.order_by(AdminCol::Password, dir),
            "name" => query.order_by(AdminCol::Name, dir),
            "admin_type" => query.order_by(AdminCol::AdminType, dir),
            "created_at" => query.order_by(AdminCol::CreatedAt, dir),
            "updated_at" => query.order_by(AdminCol::UpdatedAt, dir),
            "deleted_at" => query.order_by(AdminCol::DeletedAt, dir),
            _ => query,
        };
        Ok(next)
    }
    fn apply_cursor<'db>(&self, query: AdminQuery<'db>, column: &str, dir: SortDirection, cursor: &str) -> anyhow::Result<Option<AdminQuery<'db>>> where Self: 'db {
        let Some(col) = Self::parse_col(column) else { return Ok(None); };
        let Some(bind) = Self::parse_bind_for_col(column, cursor) else { return Ok(None); };
        let op = match dir { SortDirection::Asc => Op::Gt, SortDirection::Desc => Op::Lt };
        Ok(Some(query.where_col(col, op, bind)))
    }
    fn cursor_from_row(&self, row: &AdminView, column: &str) -> Option<String> {
        match column {
            "id" => Some(row.id.to_string()),
            "email" => Some(row.email.clone()),
            "password" => Some(row.password.clone()),
            "name" => Some(row.name.clone()),
            "created_at" => row.created_at.format(&time::format_description::well_known::Rfc3339).ok(),
            "updated_at" => row.updated_at.format(&time::format_description::well_known::Rfc3339).ok(),
            "deleted_at" => row.deleted_at.as_ref().and_then(|v| v.format(&time::format_description::well_known::Rfc3339).ok()),
            _ => None,
        }
    }
    fn count<'db>(&self, query: AdminQuery<'db>) -> BoxFuture<'db, anyhow::Result<i64>> where Self: 'db {
        Box::pin(async move { query.count().await })
    }
    fn fetch_page<'db>(&self, query: AdminQuery<'db>, page: i64, per_page: i64) -> BoxFuture<'db, anyhow::Result<Vec<AdminView>>> where Self: 'db {
        Box::pin(async move { Ok(query.paginate(page, per_page).await?.data) })
    }
}
#[derive(Debug, Clone, Copy)]
pub struct AdminDataTableConfig {
    pub default_sorting_column: &'static str,
    pub default_sorted: SortDirection,
    pub default_export_ignore_columns: &'static [&'static str],
    pub default_timestamp_columns: &'static [&'static str],
    pub default_unsortable: &'static [&'static str],
    pub default_row_per_page: Option<i64>,
}
impl Default for AdminDataTableConfig {
    fn default() -> Self {
        Self {
            default_sorting_column: "id",
            default_sorted: SortDirection::Desc,
            default_export_ignore_columns: &["actions", "action"],
            default_timestamp_columns: &["created_at", "updated_at", "deleted_at"],
            default_unsortable: &[],
            default_row_per_page: None,
        }
    }
}
pub trait AdminDataTableHooks: Send + Sync + 'static {
    fn scope<'db>(&'db self, query: AdminQuery<'db>, _input: &DataTableInput, _ctx: &DataTableContext) -> AdminQuery<'db> { query }
    fn authorize(&self, _input: &DataTableInput, _ctx: &DataTableContext) -> anyhow::Result<bool> { Ok(true) }
    fn filters<'db>(&'db self, query: AdminQuery<'db>, _input: &DataTableInput, _ctx: &DataTableContext) -> anyhow::Result<AdminQuery<'db>> { Ok(query) }
    fn mappings(&self, _record: &mut serde_json::Map<String, serde_json::Value>, _input: &DataTableInput, _ctx: &DataTableContext) -> anyhow::Result<()> { Ok(()) }
}
#[derive(Default)]
pub struct AdminDefaultDataTableHooks;
impl AdminDataTableHooks for AdminDefaultDataTableHooks {}
pub struct AdminDataTable<H = AdminDefaultDataTableHooks> where H: AdminDataTableHooks {
    pub db: sqlx::PgPool,
    pub hooks: H,
    pub config: AdminDataTableConfig,
    adapter: AdminTableAdapter,
}
impl AdminDataTable<AdminDefaultDataTableHooks> {
    pub fn new(db: sqlx::PgPool) -> Self {
        Self {
            db,
            hooks: AdminDefaultDataTableHooks,
            config: AdminDataTableConfig::default(),
            adapter: AdminTableAdapter,
        }
    }
}
impl<H: AdminDataTableHooks> AdminDataTable<H> {
    pub fn with_hooks<NH: AdminDataTableHooks>(self, hooks: NH) -> AdminDataTable<NH> {
        AdminDataTable {
            db: self.db,
            hooks,
            config: self.config,
            adapter: AdminTableAdapter,
        }
    }
    pub fn with_config(mut self, config: AdminDataTableConfig) -> Self {
        self.config = config;
        self
    }
}
impl<H: AdminDataTableHooks> AutoDataTable for AdminDataTable<H> {
    type Adapter = AdminTableAdapter;
    fn adapter(&self) -> &Self::Adapter { &self.adapter }
    fn base_query<'db>(&'db self, input: &DataTableInput, ctx: &DataTableContext) -> AdminQuery<'db> {
        self.hooks.scope(Admin::new(&self.db, None).query(), input, ctx)
    }
    fn authorize(&self, input: &DataTableInput, ctx: &DataTableContext) -> anyhow::Result<bool> { self.hooks.authorize(input, ctx) }
    fn filters<'db>(&'db self, query: AdminQuery<'db>, input: &DataTableInput, ctx: &DataTableContext) -> anyhow::Result<AdminQuery<'db>> { self.hooks.filters(query, input, ctx) }
    fn mappings(&self, record: &mut serde_json::Map<String, serde_json::Value>, input: &DataTableInput, ctx: &DataTableContext) -> anyhow::Result<()> { self.hooks.mappings(record, input, ctx) }
    fn default_sorting_column(&self) -> &'static str { self.config.default_sorting_column }
    fn default_sorted(&self) -> SortDirection { self.config.default_sorted }
    fn default_export_ignore_columns(&self) -> &'static [&'static str] { self.config.default_export_ignore_columns }
    fn default_timestamp_columns(&self) -> &'static [&'static str] { self.config.default_timestamp_columns }
    fn default_unsortable(&self) -> &'static [&'static str] { self.config.default_unsortable }
    fn default_row_per_page(&self, ctx: &DataTableContext) -> i64 { self.config.default_row_per_page.unwrap_or(ctx.default_per_page) }
}

use core_db::common::active_record::ActiveRecord;
#[async_trait::async_trait]
impl ActiveRecord for AdminView {
    type Id = uuid::Uuid;
    async fn find(db: &sqlx::PgPool, id: Self::Id) -> anyhow::Result<Option<Self>> {
        Admin::new(db, None).find(id).await.map_err(|e| e.into())
    }
}
